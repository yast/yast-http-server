/**
 * File:	modules/HttpServerWidgets.ycp
 * Package:	Configuration of http-server
 * Summary:	Widgets used by HTTP server configuration
 * Authors:	Jiri Srain <jsrain@suse.cz>
 *		Stanislav Visnovsky <visnov@suse.cz>
 *
 * $Id$
 */

{
    module "HttpServerWidgets";

    textdomain "http-server";

    import "Directory";
    import "Mode";
    import "IP";
    import "Label";
    import "Popup";
    import "Report";
    import "Service";
    import "String";
    import "LogView";
    import "TablePopup";
    import "HttpServer";
    import "YaST::HTTPDData";
    import "Confirm";
    import "SuSEFirewall";
    import "CWMServiceStart";
    import "CWMFirewallInterfaces";

    include "http-server/helps.ycp";

global string currenthost = "main";
string directory_param_regexp = "Directory \"?([^\"]+)\"?";
string dir_value = "";
map getSSLOptions();
global string init_tab = "listen";

boolean update_contents = false;
list< map<string,any> > vhost_descr = [];
string item2listen( string network, string port );

  /**
   * Validate certificate
   * @return boolean certificate valid
   */
boolean CheckCommonServerCertificate () {
    integer s = (integer)SCR::Read(.target.size, "/etc/ssl/servercerts/servercert.pem");
    if (s <= 0) {
        return false;
    }
    s = (integer)SCR::Read(.target.size, "/etc/ssl/servercerts/serverkey.pem");
    if (s <= 0) {
        return false;
    }
    return true;
}

  /**
   * Get host value
   * @param keyword string
   * @param host list< map<string, any> >
   * @param defaultvalue any
   * @return any host value
   */
global any get_host_value ( string keyword, list< map<string, any> > host, any defaultvalue )
{
    any res = defaultvalue;
    
    foreach( map<string, any> option, host, ``{
	if (option["KEY"]:nil == keyword)
	{
	    res = option["VALUE"]:defaultvalue;
	    break;
	}
    });
    
    if ( is( res, string) )
    {
	// drop quotes, if exist
	res = regexpsub ( (string)res, "\"?([^\"]*)\"?", "\\1");
    }
    
    return res;
}

  /**
   * Set host value
   * @param keyword string
   * @param host list< map<string, any> >
   * @param value any
   * @return list< map<string,any> > host map
   */
global list< map<string,any> > set_host_value ( string keyword, list< map<string, any> > host, any value )
{
    integer index = 0;
    foreach( map<string, any> option, host, ``{
	if (option["KEY"]:nil == keyword)
	{
	    break;
	}
	index = index + 1;
    });
    
    if (index >= size(host))
    {
	// adding a new option
	host[index] = $[ "KEY" : keyword , "VALUE" : value ];
    }
    else
    {
	host[index, "VALUE"] = value;
    }

    return host;
}

  /**
   * Validate server name
   * @param key any
   * @param id any
   * @param event map
   * @return boolean valid servername
   */
global boolean validate_servername (string key, map event) 
{
    import "Hostname";
    string value = (string)UI::QueryWidget (`id (key), `Value);
    if (!Hostname::CheckFQ (value))
    {
	//translators: popup error message when validate servername
	Popup::Error (_("Invalid server name.") + "\n\n" + Hostname::ValidFQ ());
	return false;
    }
    else
    {
	return true;
    }
}

  /**
   * Validate IP for host
   * @param id any
   * @param key any
   * @param event map
   * @return boolean is IP valid
   */
global boolean validate_serverip (any id, any key, map event) 
{
    import "IP";
    string value = (string)UI::QueryWidget (`id (id), `Value);
    
    // check, if there is also a port, if yes, skip it
    integer pos = search (value, ":");
    if (pos != nil)
    {
	value = substring (value, 0, pos);
    }
    
    // validate wildcard
    if (value == "*")
    {
	return true;
    }
    
    if (!IP::Check (value))
    {
        //translators: popup error message when validate server ip
	Popup::Error (_("Invalid IP address."));
	return false;
    }
    else 
    {
	return true;
    }
}

  /**
   * Function for validate server entries
   * @param hostid string
   * @param server list < map<string,any> >
   * @return boolean valid server
   */
global boolean validate_server (string hostid, list < map<string,any> > server )
{

	//TODO: don't allow user to use this directive !!!
	//main server can't use SSL
	if ( hostid == "main" )
	 {
	  foreach(map<string,any> value, server, {
	   if (value["KEY"]:"" == "SSL")
	    {
	     //translators: popup error message when validate server
	     Report::Error ( _("The default host cannot be configured with SSL support.") );
             return false;
	    }
	  });
	 }

    list <string> hosts = YaST::HTTPDData::GetHostsList ();

    string servername = (string)get_host_value ( "ServerName", server, nil );
    string ip = (string)get_host_value ( "HostIP", server, nil );
    boolean namebased = ((string)get_host_value ( "VirtualByName", server, nil )) == "1";
    string documentroot = (string) get_host_value ( "DocumentRoot", server, "" );

	// for apache2.2 ServerName is not forced (if not - hostname will be used)
    if ( size ( servername ) == 0 )
    {
        //translators: popup error message when validate server
//	Report::Error ( _("Server name cannot be empty.") );
//	return false;
	Report::Warning(_("When no Server name is defined, hostname will be used instead."));
	return true;
    }

    boolean res = true;

    foreach (string host, hosts, ``{
	if (( host == hostid ) || (hostid == "main"))
	{
	    // skip ourself also when this is main server
	    continue;
	}
	list< map<string,any> > desc = YaST::HTTPDData::GetHost (host);

	// find out the server name
	string value = (string)get_host_value ( "ServerName", desc, nil );

	if (value == servername)
	{
	    // error message - the entered server name is already configured 
	    // in another virtual host
	    Report::Error (_("The server name entered is already configured on another virtual host."));
	    res = false;
	    break;
	}

	value = (string)get_host_value ("HostIP", desc, nil);

	if (size(documentroot)<1){
	 // error message - the entered document root is empty
	 Report::Error (_("The root directory cannot be empty."));
         res = false;
         break;
	} else {
		if ( SCR::Execute(.target.bash, "test -d " + documentroot) != 0){
			// error message - the entered root directory is not valid directory
	            Report::Error (_("The root directory must be an existing directory."));
	            res = false;
	            break;
		 }
		}

	if (value == ip)
	{
	    // this is valid only if both of them are name-based, not ip-based
	    boolean based = ((string)get_host_value ( "VirtualByName", desc, nil )) == "1";
	    if ( ! (based && namebased) )
	    {
		// error message - the entered ip address is already 
		// configured for another virtual host
		string error_msg = _("The IP address is already configured on another virtual host (")+ (string) get_host_value ( "ServerName", desc, nil ) + ")";
		Report::Error (error_msg);
		res = false;
		break;
	    }
	}
    });

    // validate server admin
    string serveradmin = (string)get_host_value ( "ServerAdmin", server, nil );
    if ( ! regexpmatch ( serveradmin, ".+@.+" ))
    {
        //translators: popup error message when validate ServerAdmin
	Report::Error (_("Administrator E-Mail is invalid."));
	res = false;
    }

    return res;
}

global boolean validate_server_fnc (string id, map key);




/*********************************** inital overview table ********************************/

  /**
   * Reload server
   */
    global void ReloadServer ()
    {
	SCR::Execute (.target.bash, "rcapache2 reload");
    }
    /**
      * Handle function of the access log button (the first defined access log file)
      * @param key any key of the widget
      * @param event map event that occured
      * @return value for wizard sequencer, always nil
      */
    define symbol showAccessLogPopup (any key, map event) {
	// FIXME: log files needs to be done via HTTPDData
	// string log = (string) select( YaST::HTTPDData::GetAccessLogFiles( [currenthost] ), 0, "/var/log/apache2/access_log" );

	// strip the log format, if present
	string log = "";
//	log = select( splitstring( log, " " ), 0, "/var/log/apache2/access_log" );
	log = splitstring( log, " " )[0]:"/var/log/apache2/access_log" ;

	LogView::Display ($[
	    "command" : sformat( "tail -f %1 -n 100 | /usr/sbin/logresolve2", log ),
	    "save" : true,
	    "actions" : [
		// menubutton entry, try to keep short
		[ _("&Reload HTTP Server"), ReloadServer ],
		// menubutton entry, try to keep short
		[ _("Save Settings and Re&start HTTP Server"),
		    HttpServer::Write, true ],
	    ],
	]);
	return nil;
    }

    /**
      * Handle function of the error log button
      * @param key any key of the widget
      * @param event map event that occured
      * @return value for wizard sequencer, always nil
      */
    define symbol showErrorLogPopup (any key, map event) ``{
	// FIXME: log files needs to be done via HTTPDData
	// string log = (string) select( YaST::HTTPDData::GetErrorLogFiles( [currenthost] ), 0, "/var/log/apache2/error_log" );
	
	// strip the log format, if present
	string log = "";
//	log = select( splitstring( log, " " ), 0, "/var/log/apache2/error_log" );
	log = splitstring( log, " " )[0]:"/var/log/apache2/error_log";

	LogView::Display ($[
	    "command" : sformat( "tail -f %1 -n 100 | /usr/sbin/logresolve2", log ),
	    "save" : true,
	    "actions" : [
		// menubutton entry, try to keep short
		[ _("&Reload HTTP Server"), ReloadServer ],
		// menubutton entry, try to keep short
		[ _("Save Settings and Re&start HTTP Server"),
		    HttpServer::Write, true ],
	    ],
	]);
	return nil;
    }
//symbol showAccessLogPopup (any key, map event);
//symbol showErrorLogPopup (any key, map event);

list <string> host_ids = nil;

//void OverviewInit (string widget) { }

  /**
   * Handle overview (listen) widget
   * @param table string
   * @param event map
   * @return symbol (access/error popup)
   */
symbol OverviewHandle (string table, map event)
{
    // handle menu button entries
   if( event["ID"]:nil == `show_access_log ) {
	return showAccessLogPopup( table, event );
    }
    else if( event["ID"]:nil == `show_error_log ) {
	return showErrorLogPopup( table, event );
    }
    return nil;
}

map<string, any> overview_widget = $[
    "widget"		: `custom,
    "custom_widget"	:
	`VBox(
		Mode::config () ? `VSpacing(0) : (
		// menu button label
        	`MenuButton( `id(`menu), _("&Log Files"),
            	    // menu button item
            	    [ `item( `id( `show_access_log ), _("Show &Access Log") ),
            	    // menu button item
            	    `item( `id( `show_error_log ), _("Show &Error Log") )
        	] ) )
	),
//    "init"		:  OverviewInit,
    "handle"		:  OverviewHandle,
    "help"		:  HELPS["overview_widget"]:"",
];

/******************************************************************************************/


global void HostsInit (string widget);
global symbol HostsHandle (string table, map event);


  /**
   *
   * @param servername string
   * @param ip string
   * @return map<string,string> servername:ip
   */
map<string,string> AskNewInfo (string servername, string ip)
{
    if (size (servername) == 0)
    {
	import "DNS";
	import "Hostname";
	// suggest reasonable value
	servername = Hostname::MergeFQ (DNS::hostname, DNS::domain);
	// maybe we should check, if there is such host already
    }

    list ips = maplist( string ip, string dev, HttpServer::ip2device, ``( ip ) ) ;

    UI::OpenDialog (
	`VBox(
	    // translators: popup description on changing the default host
	    // the old default host is changed to a virtual one, but it may
	    // miss some needed information. the popup asks to set them.
	    `Label( _("The current default host will be replaced by 
the new host and will become a virtual host.

However, the current default host does not have
the IP address or the server name specified.
Therefore, it is not possible to use it as 
a virtual host. Verify the suggested values below 
and click OK to continue with the default host
switch. Otherwise click Cancel not to change
the default host.
")),
	    // translators: textentry to set the host name
	    `TextEntry (`id ("servername"), _("Server &Name:"), servername),
	    // translators: textentry to set the host IP address
	    `Left( `ComboBox( `id("ip"), `opt(`editable), _("Server &IP Address:"), ips ) ),
	    `VSpacing(0.5),
	    `HBox( `PushButton (`id(`ok), `opt(`default), Label::ContinueButton ()),
		`PushButton (`id(`cancel), Label::CancelButton ()) )
	));

    UI::SetFocus (`id("servername"));
    UI::ChangeWidget (`id("ip"), `Value, ip);

    symbol ret = nil;

    do
    {
	ret = (symbol)UI::UserInput ();
	if (ret == `cancel)
	{
	    break;
	}

	// it must be `ok
	if (! validate_servername("servername",nil))
	{
	    continue;
	}

	servername = (string)UI::QueryWidget (`id("servername"), `Value);

	if (! validate_serverip("ip",nil,nil))
	{
	    continue;
	}
	ip = (string)UI::QueryWidget (`id("ip"), `Value);

	break;

    } while (ret != nil);

    UI::CloseDialog ();
    return ret != `cancel ? $[ "name": servername, "ip" : ip ] : (map<string,string>)nil;
}


  /**
   * Hosts contents
   * @param descr map
   * @return list host list
   */
global list HostsContents (map descr) {
    return filter(string row, YaST::HTTPDData::GetHostsList (), { return (row !="main"); });
}

  /**
   * Widget for delete host
   * @param opt_id any
   * @param opt_key string
   * @return boolean delete success
   */
global boolean HostsDelete (any opt_id, string opt_key) {
    if (opt_id == "default")
    {
	// translators: popup error message - default host cannot be deleted
	Popup::Error (_("Cannot delete the default host."));
	return false;
    }
    // message popup
    if (! Popup::YesNo (_("Delete selected host?")))
	return false;
	
    HttpServer::modified = true;
    return YaST::HTTPDData::DeleteHost ((string)opt_id);
}

  /**
   * Get server name for host
   * @param key any
   * @param id string
   * @return string server name
   */
global string HostName (any key, string id)
{
    string res = (string) get_host_value ( "ServerName", YaST::HTTPDData::GetHost((string)key), (string)key );
    // translators: human-readable "default host"
    if (key == "default" && res == "default" ) res = _("Default Host");
    return res;
}

  /**
   * Get document root for host
   * @param key any
   * @param id string
   * @return string document root
   */
global string HostDocumentRootSummary( any key, string id )
{
    return (string) get_host_value ("DocumentRoot", YaST::HTTPDData::GetHost( (string)key), "");
}

  /**
   * Is that host default?
   * @param widget any
   * @param key string
   * @return boolean is_default?
   */
global boolean HostIsDefault( any widget, string key )
{
    return key == "default";
}

map<string, any> hosts_widget = (map<string, any>)TablePopup::CreateTableDescr (
	$["add_delete_buttons" : true,
	      "up_down_buttons" : false,
	      "unique_keys" : true,
	      "changed_column" : true]
	, $[
	    "init" : HostsInit,
	    "handle" : HostsHandle,
	    "ids" : HostsContents,
	    "option_delete" : HostsDelete,
	    "help" : HELPS["hosts"]:"",
	    "fallback": $[
		"summary" : HostDocumentRootSummary,
		"changed" : HostIsDefault,
		"label_func" : HostName,
	    ],
	]);

  /**
   * Handle host widget
   * @param table string
   * @param event map
   * @return symbol (`add, `edit)
   */
global symbol HostsHandle (string table, map event)
{
    if ( event["ID"]:nil == `_tp_add )
    {
	return `add;
    }

    else if (event["ID"]:nil == `_tp_edit)
    {
	currenthost = (string)UI::QueryWidget (`_tp_table, `CurrentItem);
	return `edit;
    }
    
    else if (event["ID"]:nil == `set_default)
    {
	string host = (string)UI::QueryWidget (`_tp_table, `CurrentItem);
	if (host == "default")
	{
	    // popup - it is already the default host
	    Popup::Message (_("The host is already default.") );
	    return nil;
	}

	y2milestone ("Changing default host to '%1'", host);

	list< map<string,any> > defhost_options = YaST::HTTPDData::GetHost("default");
	string servername = (string) get_host_value( "ServerName", defhost_options, "");
	string ip = (string) get_host_value( "HostIP", defhost_options, "");
	if (ip == "" || servername != "")
	{
	    // we must set a new server name and ip for the old default host
	    map res = AskNewInfo (servername, ip);
	    if (res == nil)
	    {
		// cancel the change
		return nil;
	    }

	ip =res["ip"]:ip;
	servername = res["name"]:ip;
	    defhost_options = set_host_value( "HostIP", defhost_options, ip);
	    defhost_options = set_host_value( "ServerName", defhost_options, servername);
	}
	// move the old default host elsewhere
	YaST::HTTPDData::CreateHost ( ip+"/"+servername, defhost_options );
	// replace the values of the default host by the new one
	YaST::HTTPDData::ModifyHost ("default", YaST::HTTPDData::GetHost(host) );
	// remove the old non-default host
	YaST::HTTPDData::DeleteHost (host);

	HttpServer::modified = true;

	TablePopup::TableInit(hosts_widget, table);
    }
    else
    {
	return TablePopup::TableHandle(hosts_widget, table, event);
    }
    
    return nil;
}

  /**
   * Initialize hosts table widget
   * @param widget string
   */
global void HostsInit (string widget)
{
    init_tab = "hosts";
    TablePopup::TableInit(hosts_widget, widget);
}
/******************************************************************************************/

//global string summaryGenericList(string key, any id );
global symbol handleHostTable(string key, map event );
global void HostStore (string key, map event);
global list HostTableContents (map descr);
global void DefaultHostPopupInit (any opt_id, string opt_key);
global void DefaultHostPopupStore (any opt_id, string opt_key);
global string HostTableEntrySummary (any opt_id, string opt_key);
global boolean HostTableEntryDelete (any opt_id, string opt_key);
global string HostId2Key( map desc, any id );

global void initModules (string key);
global symbol handleModules (string key, map event);
global void initListenSettings (string key);
global symbol handleListenSettings (string key, map event);
global void initServiceStatus (string key);
global symbol handleServiceStatus (string key, map event);
global void storeServiceStatus (string key, map event);
global void initAdaptFirewall (string key);
global void storeAdaptFirewall (string opt_id, map event);
//global void DirectoryOptionInit (any key, string id);
//global void DirectoryOptionStore (any key, string id);

	// wizard widget functions
global void initOpenPort (string key);
global symbol handleOpenPort(string key, map event);
global boolean validateOpenPort(string key, map event);
global void initListenInterfaces (string key);
global boolean validateListenInterfaces(string key, map event);
global void initFwOpen (string key);
global void storeFwOpen (string opt_id, map event);
//void initExpertConf (string key);
global symbol handleExpertConf (string key, map event);
void initScriptModules(string key);
void initSummaryText(string key); 
global symbol handleBooting (string key, map event);
global map getHostOptions(boolean is_main_server);
boolean getServiceAutoStart();
void setServiceAutoStart(boolean enable);
void checkLoadedModuleFor(string new);

global void setHostOptions(map < integer, map <string,any> > host_options);


string mode_replace_point_key = "replace_point";

/**
 * Map of popups for CWM
 */
global map<string,map> popups = $[
	    "ServerName" : $[
		"table" : $[
		    // table cell description
		    "label" : _("Server Name"),
		    "optional" : false,
		    "unique" : true,
		],
		"popup" : $[
		    // table cell description
		    "label"  : _("Server Name"),
		    "widget" : `textentry,
		    "validate_type" : `function,
		    "validate_function" : validate_servername,
		],
	    ],
	    "DocumentRoot" : $[
		"table" : $[
		    // table cell description
		    "label" : _("Document Root"),
		    "optional" : false,
		    "unique" : true,
		],
		"popup" : $[
		    "widget" : `textentry,
		],
            ],
	    "ServerAdmin" : $[
		"table" : $[
		    // table cell description
		    "label" : _("Server Administrator E-Mail"),
		    "optional" : false,
		    "unique" : true,
		],
		"popup" : $[
		    "widget" : `textentry,
		],
            ],
	    "VirtualByName" : $[
		"table" : $[
		    // table cell description
		    "label"  : _("Server Resolution"),
		    "optional" : false,
		    "unique" : true,
		],
		"popup" : $[
		    "widget" : `radio_buttons,
		    "items" : [
			// translators: radio button for name-based virtual hosts
			[ "1", _("Determine Request Server by HTTP &Headers") ],
			// translators: radio button for IP-based virtual hosts
			[ "0", _("Determine Request Server by Server IP &Address") ],
		    ],
		]
	    ],
	    "HostIP" : $[
		"table" : $[
		    // table cell description
		    "label"  : _("IP Address"),
		    "optional" : false,
		    "unique" : true,
		],
	    ],
	    "SSL" : $[
		"table" : $[
		    "handle" : `ssl,
		    "optional" : false,
		    "unique" : true,
		]
	    ],
	    "Directory" : $[
		"table" : $[
		"handle"   : `dir,
		"optional" : false,
		"unique"   : true,
		],
	    ],
	];

global void HostInit (string key);

global map<string, any> hostwidget = (map<string, any>)TablePopup::CreateTableDescr (
	    $["add_delete_buttons" : true, 
	      "up_down_buttons" : false, 
	      "unique_keys" : false]
	, $[
	    "init" : HostInit,
	    "handle" : handleHostTable,
	    "store" : HostStore,
	    "validate_type" : `function,
	    "validate_function" : validate_server_fnc,
	    "options" : getHostOptions(false),
	    "ids" : HostTableContents,
	    "id2key" : HostId2Key,
	    "fallback" : $[
		"init" : DefaultHostPopupInit,
		"store" : DefaultHostPopupStore,
		"summary" : HostTableEntrySummary,
	    ],
	    "option_delete" : HostTableEntryDelete,
	    "add_items" : 
		maplist( string key, any value, (map<string,any>) getHostOptions(false), ``(key) ),
	    "help" : HELPS["global_table"]:"",
	]);

  /**
   * Initialize host widget
   * @param key string
   */
global define void HostInit (string key) ``{
    if (key == "MAIN_HOST") {
			     init_tab = "main_host";
			     currenthost="main";
			    }
    TablePopup::TableInit (hostwidget, key);
}

  /**
   * Get host options
   * @return map host options
   */
global define map getHostOptions(boolean mainhost)
{
 map used = $[];
 list <string> directives = [];
	foreach (map<string,any> mod,  YaST::HTTPDData::GetKnownModules(), {
		foreach(map<string,any> option, mod["directives"]:[], {
			list<list<string> > opt_list = [];
			foreach(string value, option["values"]:[], {opt_list = add(opt_list, [ value ]);});
			if (contains(option["context"]:[] ,"Server") && !contains(option["context"]:[] ,"SSL")) 
				if (opt_list != []) used[option["option"]:""]= $["popup":$[ "widget" : `combobox, "items":opt_list ] ];
					else used[option["option"]:""]=$[];
			});
	});

y2internal("%1", mainhost);
 if (mainhost) used = union(used, filter(string key,map val, popups, { return(key!="SSL"); }));
	else used = union(used, popups);
 return used;
}
  /**
   * Get SSL options
   * @return map ssl options
   */
define map getSSLOptions()
{
 map used = $[];
 list <string> directives = [];
        foreach (map<string,any> mod,  YaST::HTTPDData::GetKnownModules(), {
                foreach(map<string,any> option, mod["directives"]:[], {
                        list<list<string> > opt_list = [];
                        foreach(string value, option["values"]:[], {opt_list = add(opt_list, [ value ]);});
                        if (contains(option["context"]:[] ,"SSL")) 
				if (opt_list != []) used[option["option"]:""]= $["popup":$[ "widget" : `combobox, "items":opt_list ] ];
                        		else used[option["option"]:""]=$[];
                        });
        });
 return used;
}


global symbol handleSSLTable(string key, map event );
global list SSLTableContents (map descr);
global void SSLInit (string key);
global void SSLStore(string key, map event);
global void SSLTypeStore (any option_id, string option_type);

global void DirInit(string key);
global symbol handleDirTable(string key, map event );
global map getDirOptions();
global list DirTableContents (map descr);
global void DirStore(string key, map event);
global void DirPopupInit (any opt_id, string opt_key);

map<integer, map<string, any> > host_options = nil;

map<string, any> sslwidget = (map<string, any>)TablePopup::CreateTableDescr (
	    $["add_delete_buttons" : true, 
	      "up_down_buttons" : false, 
	      "unique_keys" : true]
	, $[
	    "init" : SSLInit,
	    "handle" : handleSSLTable,
	    "store" : SSLStore,
	    "options" : (map<string, any>) getSSLOptions(),
	    "ids" : SSLTableContents,
	    "id2key" : HostId2Key,
	    "fallback" : $[
		"init" : DefaultHostPopupInit,
		"store" : DefaultHostPopupStore,
		"summary" : HostTableEntrySummary,
	    ],
	    "option_delete" : HostTableEntryDelete,
	    "add_items" : maplist( string key, any value, (map<string, any>) getSSLOptions(), ``(key) ),
	    "help" : HELPS["ssl"]:"",
	]);


map<string, any> dirwidget = (map<string, any>)TablePopup::CreateTableDescr (
	    $["add_delete_buttons" : true, 
	      "up_down_buttons" : false, 
	      "unique_keys" : true]
	, $[
	    "init" : DirInit,
	    "handle" : handleDirTable,
	    "store" : DirStore,
	    "options" : (map<string, any>) getDirOptions(), 
	    "ids" : DirTableContents,
	    "id2key" : HostId2Key,
	    "fallback" : $[
		"init" : DirPopupInit,
		"store" : DefaultHostPopupStore,
		"summary" : HostTableEntrySummary,
	    ],
	    "option_delete" : HostTableEntryDelete,
	    "add_items" : 
		maplist( string key, any value, (map<string,any>) getDirOptions(), ``(key) ),
	    "help" : HELPS["dir"]:"",
	]);

  /**
   * Initialize directory table
   * @param widget string
   */
global void DirInit (string widget)
{
   TablePopup::TableInit(dirwidget, widget);
}

  /**
   * Get directory options
   * @return map directory options
   */
global define map getDirOptions()
{
 map used = $[];
 list <string> directives = [];
        foreach (map<string,any> mod,  YaST::HTTPDData::GetKnownModules(), {
                foreach(map<string,any> option, mod["directives"]:[], {
                        list<list<string> > opt_list = [];
                        foreach(string value, option["values"]:[], {opt_list = add(opt_list, [ value ]);});
                        if (contains(option["context"]:[] ,"Directory") && !contains(option["context"]:[] ,"SSL"))
                                if (opt_list != []) used[option["option"]:""]= $["popup":$[ "widget" : `combobox, "items":opt_list ] ];
                                        else used[option["option"]:""]=$[];
                        });
        });
 return used;
}

  /**
   * Handle directory table
   * @param key string
   * @param  event map
   * @return symbol tablehandle
   */
global symbol handleDirTable( string key, map event )
{
    if (event["ID"]:nil == `back ) host_options = nil;

    return TablePopup::TableHandle( dirwidget, key, event );
}

  /**
   * Initialize directory popup
   * @param option_id any
   * @param option_type string
   */
   global define void DirPopupInit (any option_id, string option_type) ``{
        any value = host_options[(integer)option_id, "VALUE"]:"";
    }


  /**
   * Store directory map
   * @param key string
   * @param event map
   */
global void DirStore (string key, map event)
 {
	list< map<string,any> > options = [];

            list< map<string, any> > host = YaST::HTTPDData::GetHost(currenthost);
            foreach (map<string, any> option, host, ``{
                if ( option["KEY"]:"unknown" == "_SECTION" && option["SECTIONNAME"]:"unknown" == "Directory" 
								&& option["SECTIONPARAM"]:"unknown" == dir_value)
                {
		   list < map<string,any> > newlist = [];
		  foreach(integer key, map<string,any> value, host_options, {newlist = add(newlist, value);});
		option["VALUE"] = newlist;
                }
		options = add(options, option);
            });
	YaST::HTTPDData::ModifyHost (currenthost, options );
	setHostOptions(nil);
	HttpServer::modified = true;
 }

global void initVhostRest(string key){
	if (vhost_descr!=[]){
//                string ip = ""; foreach(map<string,any> row, vhost_descr,{if (row["KEY"]:"" == "HostIP") ip = row["VALUE"]:"";});
		boolean namebased = false;
		foreach(map<string,any> row, vhost_descr,{if (row["KEY"]:"" == "VirtualByName" && row["VALUE"]:"" == "1") namebased=true;});
//		if (size(ip)>0) UI::ChangeWidget(`id( "ipaddress" ), `Value, ip);
		if (namebased) UI::ChangeWidget(`resolution, `CurrentButton, `name_based);
			else UI::ChangeWidget(`resolution, `CurrentButton, `ip_based);
	}
	UI::ChangeWidget(`id( "ipaddress" ), `Items, maplist( string ip, string dev, HttpServer::ip2device, ``(ip) ) );
}

global void initVhostId(string key){
	if (vhost_descr!=[]){
                string servername = ""; foreach(map<string,any> row, vhost_descr,{if (row["KEY"]:"" == "ServerName") servername = row["VALUE"]:"";});
                string documentroot = ""; foreach(map<string,any> row, vhost_descr,{if (row["KEY"]:"" == "DocumentRoot") documentroot = row["VALUE"]:"";});
                string admin = ""; foreach(map<string,any> row, vhost_descr,{if (row["KEY"]:"" == "ServerAdmin") admin = row["VALUE"]:"";});
		if (size(servername)>0) UI::ChangeWidget(`id("servername"), `Value, servername);
		if (size(documentroot)>0) UI::ChangeWidget(`documentroot, `Value, documentroot);
		if (size(admin)>0) UI::ChangeWidget(`admin, `Value, admin);
	}

	UI::SetFocus (`id("servername"));
}

global define symbol handleVhostRest (string key, map event){
 if ( UI::QueryWidget(`resolution, `CurrentButton)==`name_based ) UI::ChangeWidget(`id("ipaddress"), `Enabled, false);
      else UI::ChangeWidget(`id("ipaddress"), `Enabled, true);
 return nil;
}

/**
 * Map of widgets for CWM
 */
global map<string, map <string, any> > widgets = $[
	    "server_enable" : $[
		"widget" : `radio_buttons,
		// translator: server enable/disable radio button group
		"label"	 : _("HTTP &Service"),
		"items"	 : [
		    // translators: service status radio button label
		    [ "disabled", _("Disabled") ],
		    // translators: service status radio button label
		    [ "enabled", _("Enabled") ]
		],
		"init"	: initServiceStatus,
		"handle" : handleServiceStatus,
		"store"	 : storeServiceStatus,
		"handle_events" : [ "enabled", "disabled" ],
		"opt" : [ `notify ],
		"help" : HELPS["server_enable"]:"",
	    ],
	    "firewall_adapt" : CWMFirewallInterfaces::CreateOpenFirewallWidget ($[
                "services" : [ "http" ],
		"help" : HELPS["firewall_adapt"]:"",
                "display_details" : true,
              ]),
	     "firewall_first" : $[
		"widget" : `checkbox,
		// translators: checkbox label
		"label" : _("Open &Firewall on Selected Ports"),
		"help"	 : HELPS["firewall_adapt"]:"",
		"init"	: initAdaptFirewall,
		"store"	 : storeAdaptFirewall,
	    ],
	    "host" : hostwidget,
        "LISTEN" : $[
            "widget" : `custom,
            "custom_widget" : `VBox (
                // translators: radio button group label
                `Left(`Label( _("Listen on Ports:") ) ),
                `Table (`id (`listen), `header (
                    // table header
                    _("Network Address"),
                    // table header
                    _("Port")
                ), []),
                `HBox (
                    `PushButton (`id (`add), `opt (`key_F3),
                        Label::AddButton ()),
                    `PushButton (`id (`edit), `opt (`key_F4),
                        Label::EditButton ()),
                    `PushButton (`id (`delete), `opt (`key_F5),
                        Label::DeleteButton ()),
                    `HStretch ()
                )
            ),
            "init" : initListenSettings,
            "handle" : handleListenSettings,
            "help" : HELPS["listen"]:"",
          ],
        "MODULES" : $[
                     "widget" : `custom,
            "custom_widget" : `VBox (
                `Table (`id (`modules), `header (
                    // table header: module name
                    _("Name"),
                    // table header: module status
                    _("Status")+"    ",
                    // table header: module description
                    _("Description")
                ), []),
                `HBox (
                    `PushButton (`id (`toggle),
                    // translators: toggle button label
                        _("&Toggle Status") ),
                    `HStretch (),
                    `PushButton (`id (`add_user),
                    // translators: add user-defined module button label
                        _("&Add Module") )
                )
            ),
            "init" : initModules,
            "handle" : handleModules,
            "help" : HELPS["modules"]:"",

         ],

        "MAIN_HOST" :
           TablePopup::CreateTableDescr (
            $["add_delete_buttons" : true, "up_down_buttons" : false, "unique_keys" : false],
             $[
              "init" : HostInit,
              "handle" : handleHostTable,
              "store" : HostStore,
              "validate_type" : `function,
              "validate_function" : validate_server_fnc,
              "options" : getHostOptions(true),
              "ids" : HostTableContents,
              "id2key" : HostId2Key,
              "fallback" : $[
                "init" : DefaultHostPopupInit,
                "store" : DefaultHostPopupStore,
                "summary" : HostTableEntrySummary,
                        ],
              "option_delete" : HostTableEntryDelete,
              "add_items" : maplist( string key, any value, (map<string,any>) getHostOptions(true), ``(key) ),
              "help" : HELPS["global_table"]:""
             ]
            ),

        "HOSTS" : TablePopup::CreateTableDescr (
        $["add_delete_buttons" : true,
              "up_down_buttons" : false,
              "unique_keys" : true,
              "changed_column" : true]
        , $[
            "init" : HostsInit,
            "handle" : HostsHandle,
            "ids" : HostsContents,
            "option_delete" : HostsDelete,
            "help" : HELPS["hosts"]:"",
            "fallback": $[
                "summary" : HostDocumentRootSummary,
                "changed" : HostIsDefault,
                "label_func" : HostName,
            ],
         ]),
	    "logs" : overview_widget,
	    "hosts"	: hosts_widget,
	    "ssl" : sslwidget,
	    "dir" : dirwidget,
		// wizard widgets
	    "open_port" : $[
		"widget" : `textentry,
		// translators: text entry
		"label"	 : _("&Port:"),
		"init"	 : initOpenPort,
		"validate_type" : `function, 
		"validate_function" : validateOpenPort,
		"help" : HELPS["open_port"]:""
		],
	   "listen_interfaces" : $[
		"widget" : `custom,
		// translators: multi selection box
		"custom_widget" : `ReplacePoint( `id(mode_replace_point_key),`MultiSelectionBox( _("&Listen on Interfaces"), [])),
		"init"	 : initListenInterfaces,
                "validate_type" : `function,
                "validate_function" : validateListenInterfaces,
		"help" : HELPS["listen_interfaces"]:""
		],
	   "fw_open" : $[
		"widget" : `checkbox,
		//translators: checkbox 
		"label"  : _("Open &Firewall for Selected Ports"),
		"init"	 : initFwOpen,
		"store"	 : storeFwOpen,
		"help"   : HELPS["fw_open"]:""
		],
	  "booting" 	 : CWMServiceStart::CreateAutoStartWidget ($[
		"get_service_auto_start" : getServiceAutoStart,
		"set_service_auto_start" : setServiceAutoStart,
		//translators: radiobutton - to start Apache2 service automatically
		"start_auto_button"	 : _("Start Apache2 Server When Booting"),
		//translators: radiobutton - to don't start Apache2 service 
		"start_manual_button"	 : _("Start Apache2 Server Manually")

		]),
	  "expert_conf"  : $[
		"widget" : `push_button,
		//translators: button to enter expert configuration
		"label"  : _("&HTTP Server Expert Configuration..."),
//		"init"	 : initExpertConf,
		"handle" : handleExpertConf,
		"help"	 : HELPS["expert_conf"]:""
		],
	  "script_modules" : $[
		"widget" : `custom,
		"custom_widget" : `ReplacePoint(`id(`scr_mod_replace), 
			`Label("") 
	                ),
		"init"   : initScriptModules,
		"help"	 : HELPS["script_modules"]:""
		],
	   "vhost_id" : $[
		"widget" : `custom,
                "custom_widget" :
	    `Frame(
		// translators: frame title for new hsot identification details
		_("Server Identification"),
		`VBox(
		    // translators: textentry, new host server name
		    `TextEntry( `id( "servername" ), _("Server &Name:") ),
		    `HBox(
			// translators: textentry, document root for the new host
			`TextEntry( `id( `documentroot ), _("Server &Contents Root:") ),
			`VBox(
                	    `Label(""),
			    `PushButton( `id( `browse ), Label::BrowseButton () )
			)
		    ),
		    // translators: textentry, administrator's e-mail for the new host
		    `TextEntry( `id( `admin ), _("&Administrator E-Mail:") )
		)),
		"help" : HELPS["vhost_id"]:"",
		"init" : initVhostId
			],
	   "vhost_res" : $[
		"widget" : `custom,
                "custom_widget" :
	    `Frame(
		// translators: frame title for method of incoming request resolution
		_("Server Resolution"),
		`VBox(
		// translators: IP address for the new host
		`Left( `ComboBox( `id( "ipaddress" ), `opt(`editable), _("&IP Address:"), [] ) ),
		`RadioButtonGroup(
		    `id ( `resolution ),
		    `VBox (
			// translators: radio button for name-based virtual hosts
			`Left(`RadioButton ( `id ( `name_based ), `opt(`notify), _("Determine Request Server by HTTP &Headers"), true ) ),
			// translators: radio button for IP-based virtual hosts
			`Left(`RadioButton ( `id ( `ip_based ),`opt(`notify), _("Determine Request Server by Server IP &Address") ) )
		    )
		))),
		"init" : initVhostRest,
		"handle" : handleVhostRest,
		"help" : HELPS["vhost_res"]:""
		],
	   "summary_text" : $[
		"widget"  : `custom,
		"custom_widget" : `ReplacePoint(`id(`summary_text_rp), `RichText("")),
		"init"	  : initSummaryText,
		"help"	  : HELPS["summary_text"]:""
		]
	];


/******************************** SSL widget ****************************/

  /**
   * Handle SSL widget table
   * @param key string
   * @param event map
   * @return symbol sslhandle
   */
global symbol handleSSLTable( string key, map event )
{
    if ( event["ID"]:nil == `import_certificate )
    {
				//translators: dialog to set *.pem file with certificate
	string pem = UI::AskForExistingFile ("/", "*.pem", _("Select Certificate"));
	if (pem == nil)
	{
	    // cancel
	    return nil;
	}

	string cert = (string) SCR::Read ( .target.string, pem );
	if (cert != nil)
	{
	    // pass the data to the backend
	    YaST::HTTPDData::SetCert ( currenthost, "CERT", cert );

	    // get the correct host name
	    list<map<string,any> > host = YaST::HTTPDData::GetHost (currenthost);
	    host = set_host_value( "SSLCertificateFile", host,
		"/etc/apache2/ssl.crt/"
		+ (string)get_host_value ("ServerName", host, "default")
		+ "-cert.pem");
	    YaST::HTTPDData::ModifyHost (currenthost, host);
	    TablePopup::TableInitWrapper(key);
	    return nil;
	}

	// translators: error message un failed certificate import
	Report::Error ( sformat( _("Cannot import certificate
%1"), pem));
    }
    else if (event["ID"]:nil == `common_certificate )
    {
	string pem = "/etc/ssl/servercerts/servercert.pem";
	if ( !CheckCommonServerCertificate () )
	{
			//translators: dialog to set *.pem file with certificate
	    pem = UI::AskForExistingFile ("/etc/ssl/servercerts", "*.pem", _("Select Certificate"));
	    if (pem == nil)
	    {
		// cancelled
		return nil;
	    }
	}
	else
	{
	    list<map<string,any> > host = YaST::HTTPDData::GetHost (currenthost);
	    host = set_host_value( "SSLCertificateFile", host, "/etc/ssl/servercerts/servercert.pem");
	    host = set_host_value( "SSLCertificateKeyFile", host, "/etc/ssl/servercerts/serverkey.pem");
	    YaST::HTTPDData::ModifyHost (currenthost, host);
	}

	TablePopup::TableInitWrapper(key);
	return nil;
    }
    else if (event["ID"]:nil == `back )
    {
        host_options = nil;
    }

    return TablePopup::TableHandle( sslwidget, key, event );
}

  /**
   * Initialize SSL widget
   * @param widget string
   */
global void SSLInit (string widget)
{
    TablePopup::TableInit(sslwidget, widget);
}

  /**
   * Store SSL setting
   * @param key string
   * @param event map
   */
global void SSLStore (string key, map event)
 {
	boolean found = false ;
        list < map<string,any> > forssl = [];
        list < map<string,any> > fordir = [];


        foreach(integer key, map<string,any> value, host_options, {
      foreach(map<string,any> val, YaST::HTTPDData::GetKnownModules(), {
	   if ( val["name"]:"" == "ssl" )
	    {
		foreach(map<string, any> pom, val["directives"]:[], {
			if (pom["option"]:"" == value["KEY"]:"")
			 {
				if ( contains(pom["context"]:[], "Directory")) { fordir = add(fordir, value); }
                                if ( contains(pom["context"]:[], "Server"))    { forssl = add(forssl, value); }
			 }
		});
	    }
          });
	});

        list< map<string,any> > options = [];
            foreach (map<string, any> option, YaST::HTTPDData::GetHost(currenthost), ``{
                if ( option["KEY"]:"unknown" == "_SECTION" && option["SECTIONPARAM"]:"unknown" == "SSL")
                {
		   found = true;
                option["VALUE"] = forssl;
		  if ( forssl != [] ) options = add(options, option);
                } else if ( option["KEY"]:"unknown" == "_SECTION" && option["SECTIONNAME"]:"unknown" == "Directory")
		 {
		  list< map<string, any> > temp_dir = [];
		  foreach(map<string, any> value, option["VALUE"]:[], {
			if (!(value["KEY"]:"unknown" == "_SECTION" && value["SECTIONPARAM"]:"unknown" == "SSL")) temp_dir = add(temp_dir, value);
			});
		  if (fordir != []) option["VALUE"] = add(temp_dir, $["KEY":"_SECTION", "SECTIONNAME":"IfDefine", "SECTIONPARAM":"SSL", "VALUE":fordir]);
			else 
			 {
			  list< map<string, any> > dir_newlist = [];
			  foreach(map< string, any > dir_item, 
					option["VALUE"]:[], 
					{
					if (!(dir_item["KEY"]:"" == "_SECTION" && dir_item["SECTIONPARAM"]:"" == "SSL")) 
						dir_newlist = add(dir_newlist, dir_item);
					});
				option["VALUE"] = dir_newlist;
			 }

		options = add(options, option);
		 } else options = add(options, option);
            });
	if (found == false) { options = add(options, $["KEY":"_SECTION", "SECTIONNAME":"IfDefine", "SECTIONPARAM":"SSL", "VALUE":forssl]); }
        YaST::HTTPDData::ModifyHost (currenthost, options );
        setHostOptions(nil);
        HttpServer::modified = true;
 }

/******************************** Listen popup ****************************/

/**
 * Convert a Listen string to an item for table. Splits by the colon.
 *
 * @param arg		the Listen map
 * @param id		the id of this item
 * @return term		term for the table
 */
global define term listen2item( map<string,any> arg, integer id ) ``{

	//translators: all network addresses Listen type
    string address = arg["ADDRESS"]: _("All Addresses");
        //translators: all network addresses Listen type
    if (address == "") address = _("All Addresses");
    string port = arg["PORT"]:"80";
    
    return `item( `id(id), address, port );
}

/**
 * Convert a Listen string to an item for table. Splits by the colon.
 *
 * @param network	network address
 * @param port		port number
 * @return string 	Listen value
 */
define string item2listen( string network, string port ) ``{

        //translators: all network addresses Listen type
    if( network == _("All Addresses") ) network = "";
    
    if( size(network) > 0 ) port = network +":"+ port ;
    
    return port;
}

    /**
     * Show a popup for editing Listen statement.
     *
     * @param network string initial value for the network part of the statement
     *                  If empty or _("All Addresses"), considered for all Listen for all interfaces.
     * @param port string initial value for a port number
     * @return map<string,string>	the new Listen statement or nil if Cancel was pressed
     */
    define map<string,string> AskListen( string network, string port ) ``{
	// translators: all network addresses Listen type
	boolean adr_type = ( network == _("All Addresses") || network == "" );
	if( port == nil ) port = "";

	// translators: Listen type for all addresses;
	string aa =  _("All Addresses");

	list ips = union( [ aa ], maplist( string ip, string dev, HttpServer::ip2device, ``( ip ) ) );

	UI::OpenDialog( `VBox(
	    `TextEntry( `id(`port), Label::Port(), port ),
	    // translators: combo box label for list of configured IPs
	    `Left( `ComboBox( `id("address"), `opt( `editable ), _("Network &Address:"), ips ) ),
	    `VSpacing(),
	    `HBox( 
		`PushButton( `id(`ok), Label::OKButton() ),
		`PushButton( `id(`cancel), Label::CancelButton() )
	     )
	));

	if( !adr_type ) {
	    UI::ChangeWidget( `id( "address" ), `Value, network );
	}

	symbol ret = nil;
	map<string,string> res = $[];
	do {

	    ret = (symbol) UI::UserInput();

	    if( ret == `ok ) {
		res["ADDRESS"] = (string)UI::QueryWidget( `id("address"), `Value );
		res["PORT"] = (string)UI::QueryWidget( `id(`port), `Value );
		if ( res["ADDRESS"]:nil == aa ) 
		{
		    // on all addresses, cleanup the value
		    res["ADDRESS"] = "";
		}
		else
		{
		    // validate
		    if (! validate_serverip ("address", nil, nil) )
		    {
			ret = nil;
			continue;
		    }
		}

		// validation
		if( ! regexpmatch( res["PORT"]:"", "^[ \t]*[0-9]+[ \t]*$" ) ) {
		    // translators: error message when validating Listen statement
		    Popup::Error( _("Invalid port number.") );
		    ret = nil;
		    continue;
		}

	    }
	} while( ret != `ok && ret != `cancel );

	if( ret == `cancel ) res = nil;

	UI::CloseDialog();

	return res;
    }

// *************************************** log popups **************************


// ************************************ default host table ********************

    integer option_counter = 0;
    list<integer> deleted_options = [];

  /**
   * Validate server function
   * @param id string
   * @param key map
   * @return boolean validate
   */
    global boolean validate_server_fnc (string id, map key) 
    {
	// convert the map to list
	list< map<string, any> > val = maplist (integer index, map<string, any> data
	    , host_options, ``(data));
	return validate_server ( currenthost, val );
    }

  /**
   * Get value from id
   * @param desc map
   * @param option_id any
   * @return string value
   */
    global string HostId2Key( map desc, any option_id )
    {
	return host_options [ (integer)option_id, "KEY" ]: "";
    }

  /**
   * find modules of all directives and check if are loaded
   * @param new string
   */
    void checkLoadedModuleFor(string new)
    {
	list<string> loaded = YaST::HTTPDData::GetModuleList();
      foreach(map<string,any> value, YaST::HTTPDData::GetKnownModules(), {
	 if (contains(value["directives"]:[], new) && !contains(loaded, value["name"]:"")) 
	  {
	   YaST::HTTPDData::ModifyModuleList([value["name"]:""], true);
	   y2milestone("loading module mod_%1 ...", value["name"]:"");
	  }
	});

    }

  /**
   * Store host settings
   * @param key string
   * @param event map
   */
    global void HostStore (string key, map event)
    {

	list< map<string,any> > options = []; 
       foreach (integer key, map<string,any> values, host_options,
        ``{
	   if (haskey(values, "DATA"))
	    {

		//In main host SSL can't be used
/*
	     if (values["KEY"]:"" == "SSL") 
		{
		 options = add(options, $[
                   "KEY"       : "_SECTION",
                    "SECTIONNAME": "IfDefine",
                    "SECTIONPARAM": "SSL",
                    "VALUE" : values["DATA"]: [],
                    "OVERHEAD" : values["OVERHEAD"]:""]);
		 y2milestone("SSL section - %1", options);
		}
*/

             if (values["KEY"]:"" == "Directory") 
		{
                options = add(options, $[
                   "KEY"       : "_SECTION",
                    "SECTIONNAME": "Directory",
                    "SECTIONPARAM": values["VALUE"]:"",
                    "VALUE" : values["DATA"]: [],
                    "OVERHEAD" : values["OVERHEAD"]:""]);
		 y2milestone("Directory section - %1", values);
		}
	    } else 
		{
		 options = add(options, values);
		 y2milestone("Global section - %1", values);
		}
	  });

	options = filter (map <string,any> option, options, ``( option != nil ));

	// for all host options check whether module from directive is loaded
        foreach (map<string, any> values, options, ``{
							checkLoadedModuleFor(values["KEY"]:"");
							});
	YaST::HTTPDData::ModifyHost (currenthost, options );

	setHostOptions(nil);
    }

  /**
   * Set host options
   * @param new_options map < integer, map < string,any > >
   */
    global void setHostOptions( map < integer, map < string,any > > new_options)
     {
	host_options = new_options;
     }
    
    /**
      * Function for getting contents of the default host table
      * @param descr map description map of the table
      * @return list of items for the table
      */
    global define list HostTableContents (map descr) ``{
    
	if (host_options == nil)
	{
	    // fill the data
	    option_counter = 0;
	    host_options = $[];
	    deleted_options = [];
	    list res = [];
	    
	    // flags, whether the required entries are present
	    boolean servername = false;
	    boolean serveradmin = false;
	    boolean documentroot = false;
    
	    list< map<string, any> > host = YaST::HTTPDData::GetHost(currenthost);
	   
	    foreach (map<string, any> option, host, ``{
		string key = option["KEY"]: "unknown";
		
		if (key == "ServerName") servername = true;
		if (key == "ServerAdmin") serveradmin = true;
		if (key == "DocumentRoot") documentroot = true;
	    
		if ( key == "_SECTION" && option["SECTIONNAME"]:"" == "Directory" )
		{
		    host_options[option_counter] = $[
			"KEY" : "Directory",
			"VALUE" : option["SECTIONPARAM"]:"",
			"DATA": option["VALUE"]:[],
			"OVERHEAD" : option["OVERHEAD"]:""
		    ];
		    res = add (res, option_counter);
		    option_counter = option_counter + 1;
		}

		if ( key == "_SECTION" && option["SECTIONPARAM"]:"" == "SSL" )
			{
			    host_options[option_counter] = $[
				"KEY" : "SSL",
				"VALUE" :  "", 
				"DATA": option["VALUE"]:[],
				"OVERHEAD" : option["OVERHEAD"]:""
		    ];
		    res = add (res, option_counter);
		    option_counter = option_counter + 1;
		}


		// skip SECTIONS
		if ( key == "_SECTION" ) 
		{
		    option_counter = option_counter + 1;
		    continue;
		}
		// skip HostIP for default host
		else if (currenthost == "main" && key == "HostIP")
		{
		    host_options[option_counter] = option;
		    option_counter = option_counter + 1;
		    continue;
		}
		else
		{			
		    host_options[option_counter] = option;
		    res = add (res, option_counter);
		    option_counter = option_counter + 1;
		}
	    });
	    
	    
	    // required entries
	    if (!servername)
	    {
		y2milestone ("Adding missing ServerName");
		host_options[option_counter] = $[
		    "KEY" : "ServerName",
		    "VALUE" : ""
		];
		res = add (res, option_counter);
		option_counter = option_counter + 1;
	    }
	    
	    if (!serveradmin)
	    {
		y2milestone ("Adding missing ServerAdmin");
		host_options[option_counter] = $[
		    "KEY" : "ServerAdmin",
		    "VALUE" : ""
		];
		res = add (res, option_counter);
		option_counter = option_counter + 1;
	    }
	    
	    if (!documentroot)
	    {
		y2milestone ("Adding missing DocumentRoot");
		host_options[option_counter] = $[
		    "KEY" : "DocumentRoot",
		    "VALUE" : ""
		];
		res = add (res, option_counter);
		option_counter = option_counter + 1;
	    }
	    
	    return res;
	}
	else
	{
	    // just generate the list of ids
	    return maplist( integer id, map<string,any> value, host_options,
		``(id));
	}
    }
    
    /**
      * Function for getting contents of the default host table
      * @param descr map description map of the table
      * @return list of items for the table
      */
    global define list SSLTableContents (map descr) ``{
       if (host_options == nil)
        {
            // fill the data
            option_counter = 0;
            host_options = $[];
            deleted_options = [];
            list res = [];

            list< map<string, any> > host = YaST::HTTPDData::GetHost(currenthost);
            foreach (map<string, any> option, host, ``{
                string key = option["KEY"]: "unknown";
                // skip non-SSL options
                if ( option["KEY"]:"unknown" == "_SECTION" && option["SECTIONPARAM"]:"unknown" == "SSL")
                {
                        foreach(map<string, any> value, option["VALUE"]:[], {
                        host_options[option_counter] = value;
                        res = add (res, option_counter);
                        option_counter = option_counter + 1;
                        });
                }
                else
                {
		    if ( option["KEY"]:"unknown" == "_SECTION" && option["SECTIONNAME"]:"unknown" == "Directory")
		     {
			foreach(map<string, any> value, option["VALUE"]:[], {
			  if (value["KEY"]:"unknown" == "_SECTION" && value["SECTIONPARAM"]:"unknown" == "SSL" && value["VALUE"]:[] != [])
			   {
				foreach(map<string, any> directive, value["VALUE"]:[],{
					boolean found=false;
					foreach(integer key, any val, host_options, {if ( val == directive ) found=true;});
					if (found == false)
					 {
		                          host_options[option_counter] =  directive;
			                  res = add (res, option_counter);
				          option_counter = option_counter + 1;
					 }
				});
			   }
                        });
		     }
                    option_counter = option_counter + 1;
                    continue;
                }
            });
            return res;
        }
        else
        {
            // just generate the list of ids
            return maplist( integer id, map<string,any> value, host_options, ``(id));
        }

    }
    /**
      * Delete function of the global table
      * @param opt_id any option id of selected option
      * @param opt_key any option key of selected option
      * @return boolean true if was really deleted
      */
    global define boolean HostTableEntryDelete (any opt_id, string opt_key) ``{
	if (! Confirm::DeleteSelected()) {
	    return false;
	}
	    
	host_options = filter ( integer opt, map<string,any> value
	    , host_options, ``(opt != opt_id) );
	    
	deleted_options = add (deleted_options, (integer)opt_id);
	
	HttpServer::modified = true;
	return true;
    }

    /**
     *  Handler for editing default host. Handles additional buttons, like logs and modules.
     *  Rest is passed to TablePopup::TableHandle.
     *
     *  @param key	the key modified
     *  @param event	event description
     *  @return symbol 	the result of the handling
     */
    global define symbol handleHostTable(string key, map event ) ``{
	dir_value = host_options[(integer)UI::QueryWidget (`_tp_table, `CurrentItem), "VALUE"]:"";

	// handle menu button entries
/*
	if( event["ID"]:nil == `show_access_log ) {
	    return showAccessLogPopup( key, event );
	}
	else if( event["ID"]:nil == `show_error_log ) {
	    return showErrorLogPopup( key, event );
	}
*/
	symbol res = TablePopup::TableHandle( hostwidget, key, event );
	if (update_contents)
	{
	    update_contents = false;
	    TablePopup::TableInit( hostwidget, key);
	}
	return res;
    }

    /**
      * Fallback initialization function of a table entry / popup
      * @param option_id any unique option id
      * @param option_type string the name of the key in the option list description
      */
    global define void DefaultHostPopupInit (any option_id, string option_type) ``{
	any value = host_options[(integer)option_id, "VALUE"]:"";
	
	if (option_type == "VirtualByName")
	{
	    UI::ChangeWidget (`id (option_type), `CurrentButton, value);
	}
	else
	{
	    UI::ChangeWidget (`id (option_type), `Value, value);
	}
    }

    /**
      * Fallback store function of a table entry / popup
      * @param option_id any option id
      * @param option_type string option key
      */
    global define void DefaultHostPopupStore (any option_id, string option_type) ``{
	symbol property = (option_type == "VirtualByName") ? `CurrentButton : `Value;
	
	if (option_id == nil)
	{
	    // new option
	    host_options[ option_counter ] = $[
		"KEY": option_type,
	    ];
	    option_id = option_counter;
	    option_counter = option_counter + 1;
	}
	
	host_options[ (integer)option_id, "VALUE" ] = (string)UI::QueryWidget (`id (option_type), property);
	HttpServer::modified = true;
    }

    /**
      * Fallback summary function of a table entry / popup
      * @param option_id any option unique id
      * @param option_type string option type
      * @return string table entry summary
      */
    global define string HostTableEntrySummary (any option_id, string option_type) ``{
	if (option_type == "VirtualByName")
	{
	    if (host_options[ (integer)option_id, "VALUE"]:"" == "1")
	    {
		// translators: table entry text for name-based vhosts
		return _("Resolution via HTTP Headers");
	    }
	    else 
	    {
		// translators: table entry text for IP-based vhosts
		return _("Resolution via IP Address Used");
	    }
	}
	else if (option_type == "Directory")
	{
	    return host_options[ (integer)option_id, "VALUE" ]:"" + "...";
	}
	else 
	{
	    return host_options[ (integer)option_id, "VALUE" ]: "";
	}
    }

  /**
   * Store SSL type
   * @param option_id any
   * @param option_type string
   */
    global void SSLTypeStore (any option_id, string option_type)
    {
	// it is a radio button group
	host_options[(integer)option_id, "VALUE"] = 
	    UI::QueryWidget( `id(option_type), `CurrentButton );
	HttpServer::modified = true;
    }

  /**
   * Contents of host table
   * @param descr map
   * @return list host contents
   */
    global define list DirTableContents (map descr) ``{
	if (host_options == nil)
	{
	    // fill the data
	    option_counter = 0;
	    host_options = $[];
	    deleted_options = [];
	    list res = [];

	    list< map<string, any> > host = YaST::HTTPDData::GetHost(currenthost);
	    foreach (map<string, any> option, host, ``{
		string key = option["KEY"]: "unknown";

		if ( option["KEY"]:"unknown" == "_SECTION" && option["SECTIONNAME"]:"unknown" == "Directory" 
									&& option["SECTIONPARAM"]:"unknown"==dir_value)
		{
			foreach(map<string, any> value, option["VALUE"]:[], {
			if (!(value["KEY"]:""=="_SECTION" && value["SECTIONPARAM"]:""=="SSL"))
			 {
			  host_options[option_counter] = value;
			  res = add (res, option_counter);
			  option_counter = option_counter + 1;
			 }
			});
		}
		else
		{
		    option_counter = option_counter + 1;
		    continue;
		}
	    });
	    return res;
	}
	else
	{
	    // just generate the list of ids
	    return maplist( integer id, map<string,any> value, host_options, ``(id));
	}
    }

// ************************************ modules list ***************************

    /**
      * Initialize function of a widget
      * @param key any widget key of widget that is processed
      */
    global define void initModules (string key) ``{
	list< map<string,any> > known = YaST::HTTPDData::GetKnownModules();
	list<string> modules = YaST::HTTPDData::GetModuleList();
	integer index = -1;
       // create temporary list of maps from modules
       list< map<string, any > > listmodules = maplist(string name , modules,{
                       return( mapmap(string k,any v, $["default":"1", "name":name, "summary":_("unknown"), "required":"0", "suggested":"0"],
                               {return ($[k:v]); }));
       });

       // add to known modules list modules from temporary list
       foreach(map<string, any> mapmodules, listmodules, {
        boolean finded=false;
        foreach(map<string, any> mapknownmodules, known, {
		//translators: list of known and unknown modules
         if ( mapknownmodules["name"]:_("unknown") ==  mapmodules["name"]:_("unknown") ) finded=true;

        });
         if (!finded) known=add(known, mapmodules);
       });

	list<term> items = maplist (map<string,any> mod, known , ``{
	    index = index + 1;
	    // translators: server module status unknown
	    string name = mod["name"]:_("unknown");
	if ((mod["default"]:"0" == "1") && (!contains(modules, name))) YaST::HTTPDData::ModifyModuleList ([name], true);
	    // translators: server module status
	    return `item (`id (index), name, (contains( modules, name)||mod["default"]:"0"=="1") ? _("Enabled") 
		// translators: server module status
		: _("Disabled"), mod["summary"]:"" );
	});
	UI::ChangeWidget (`id (`modules), `Items, items);
	UI::SetFocus (`id (`modules));
    }

    /**
      * Handle function of a widget
      * @param key any widget key of widget that is processed
      * @param event any event that occured
      * @return symbol symbol for WS or nil
      */
    global define symbol handleModules (string key, map event) ``{
	UI::SetFocus (`id (`modules));
        if (event["ID"]:nil == `toggle)
        {
	    integer ci = (integer) UI::QueryWidget( `id( `modules ), `CurrentItem );

//	    string status = (string) select( (term) UI::QueryWidget( `id(`modules), `Item(ci) ), 2, _("Enabled") );
	    string status = ((term)UI::QueryWidget( `id(`modules), `Item(ci) ))[2]: _("Enabled") ;
//	    string name = (string) select( (term) UI::QueryWidget( `id(`modules), `Item(ci) ), 1, nil );
	    string name = ((term) UI::QueryWidget( `id(`modules), `Item(ci) ))[1]:"";	
	    y2debug( "Status of module: %1", status );
	    if( status == _("Enabled") ) status = _("Disabled");
	 	   else status = _("Enabled");
	    UI::ChangeWidget( `id( `modules ), `Item( ci , 1 ) , status );
	foreach(map<string, any> mods, YaST::HTTPDData::GetKnownModules(), {
	 if (name == mods["name"]:"" && status == _("Enabled") && mods["exclude"]:nil != nil) 
	  {
		foreach(string exclude, mods["exclude"]:[], {
		 YaST::HTTPDData::ModifyModuleList ([exclude], false);
		  foreach (any excl_row, (list)UI::QueryWidget( `id(`modules), `Items ), {
		    if (exclude == ((term)excl_row)[1]:"" ) {
			integer row = (integer)((term)    ((term)excl_row)[0]:nil)[0]:nil;
			if (row != nil) UI::ChangeWidget( `id( `modules ), `Item( row , 1 ) , _("Disabled") );
			};
		  });
		 y2milestone("Disabling module %1 excluded by %2", exclude, name);
		});
	 }
 
	});
	    YaST::HTTPDData::ModifyModuleList ([name], status == _("Enabled"));
	    HttpServer::modified = true;
        }
	else if (event["ID"]:nil == `add_user)
        {
	// list of all installed modules
	    list <string> modules_dir = splitstring(((map<string, any>) SCR::Execute(.target.bash_output, 
									"ls /usr/lib/apache2/|grep so|cut -d. -f1|cut -d_ -f2-"))["stdout"]:"", "\n");
	    list<string> existing = maplist (map<string,any> mod,  YaST::HTTPDData::GetKnownModules(), ``(
		mod["name"]:_("unknown")));
	// extract unknown modules from all installed
	    list<string> unknown_modules = [];
	    foreach(string single_module, modules_dir, {
		if ((!contains(existing, single_module))&&(single_module != "")) unknown_modules=add(unknown_modules, single_module);
	    });
	y2milestone("List of new modules %1", unknown_modules);
	   UI::OpenDialog(
            `VBox(
		// translators: combo box for selsect module from installed unknown modules
		`ComboBox(`id(`mod), _("New Module &Name:"),  unknown_modules ),
                `HBox(
                    `PushButton(`id(`ok), `opt(`default), Label::OKButton() ),
                    `PushButton(`id(`cancel), Label::CancelButton() )
            	    )
        	)
    	    );
	    
	    UI::SetFocus( `id( `mod ) );

	    symbol ret = (symbol) UI::UserInput();
	    
	    if( ret == `ok ) {
		string mod = String::CutBlanks( (string) UI::QueryWidget( `id(`mod), `Value ) );
		if( mod == "" ) {
		    // translators: error message
		    Report::Error( _("A name for the module to add is required.") );
		} else if( contains( existing, mod )  ) {
		    // translators: error message
		    Report::Error( _("The module is already in the list.") );
		} else {
		    YaST::HTTPDData::ModifyModuleList( [mod], true );
		    HttpServer::modified = true;
		}
	    }
	    UI::CloseDialog();
	    initModules(nil);
        }

    }

// ************************************ listen settings ************************

    /**
      * Initialize function of a widget
      * @param key any widget key of widget that is processed
      */
    global define void initListenSettings (string key) ``{

	integer id = -1;
	list< map<string,any> > listen = YaST::HTTPDData::GetCurrentListen();
	y2milestone ("Listen: %1", listen);
	list<term> items = maplist( map<string,any> litem, listen, ``{ id = id+1; return listen2item(litem, id); } );
	UI::ChangeWidget (`id (`listen), `Items, items);
	
	// enable/disable buttons - at least single Listen must be present
	UI::ChangeWidget (`id (`delete), `Enabled, size( listen ) > 1 );
	
	// set focus
	UI::SetFocus (`id (`listen));
    }

    /**
      * Handle function of a widget
      * @param key any widget key of widget that is processed
      * @param event map event that occured
      * @return symbol symbol for WS or nil
      */
    global define symbol handleListenSettings (string key, map event) ``{
	UI::SetFocus (`id (`listen));
	integer current = (integer) UI::QueryWidget (`id (`listen), `CurrentItem);
	term currentitem = current != nil ? (term) UI::QueryWidget( `id(`listen), `Item(current) ) : `item( -1, "", "");
	string network = (string) currentitem[1]:nil;
	// translators: all network addresses Listen type
	if( network == _("All Addresses") ) network = "";
	string port = currentitem[2]:"";

        if (event["ID"]:nil == `add)
        {
	    // translators: all network addresses Listen type
	    map<string,string> res = AskListen( _("All Addresses"), "" );
	    if( res != nil ) {
		if (false) // FIXME: CreateListen error reporting
		{
		    // translators: error message for adding a new Listen statement
		    Popup::Error( sformat(_("The entry '%1' already exists."), res) );
		} 
		else
		{
		    YaST::HTTPDData::CreateListen( tointeger(res["PORT"]:"80"), tointeger(res["PORT"]:"80"),
			res["ADDRESS"]:"" );
		    HttpServer::modified = true;
		}
	    }
        }
	else if( event["ID"]:nil == `delete )
	{
	    boolean validate = size( YaST::HTTPDData::GetCurrentListen() ) != 0;

	    y2debug( "Validation result: %1", validate );
	
	    if( !validate ) {
		// translators: error message
		Popup::Error(_("The list of the ports to which the server should
listen cannot be empty.") );
	    return nil;
	    }

	    // remove the entry
	    YaST::HTTPDData::DeleteListen( tointeger(port), tointeger(port), network );
	    HttpServer::modified = true;
	}
	else if( event["ID"]:nil == `edit )
	{
	    map<string,string> res = AskListen( network, port );
	    if( res != nil ) {
		// remove the old one
		YaST::HTTPDData::DeleteListen( tointeger(port), tointeger(port),
			network );
		// create the new one
		YaST::HTTPDData::CreateListen( tointeger(res["PORT"]:"80"), tointeger(res["PORT"]:"80"),
			res["ADDRESS"]:"" );
		HttpServer::modified = true;
	    }
	}
	
	initListenSettings(nil);
    }

    
// ************************************ server status ***********************

    /**
      * Initialize function of a widget
      * @param key any widget key of widget that is processed
      */
    global define void initServiceStatus (string key) ``{
	if( YaST::HTTPDData::GetService()!=nil && YaST::HTTPDData::GetService()  ) {
	    UI::ChangeWidget (`id ("enabled"), `Value, true);
	}
	else 
	{
	    UI::ChangeWidget (`id ("disabled"), `Value, true);
	}
    }

    /**
      * Store function of a widget
      * @param key any widget key of widget that is processed
      * @param event map event that occured
      */
    global define void storeServiceStatus (string key, map event) ``{
	YaST::HTTPDData::ModifyService( (boolean) UI::QueryWidget ( `id("enabled"), `Value ) );
	HttpServer::modified = true;
    }
  /**
   * Handling service status
   * @param key string
   * @param event map
   * @return symbol (`overview_table, `edit. `menu)
   */
    global symbol handleServiceStatus (string key, map event)
    {
	// enable/disable overview widget
	boolean enable = (boolean)UI::QueryWidget (`id("enabled"), `Value );

	UI::ChangeWidget (`overview_table, `Enabled, enable);	
	UI::ChangeWidget (`edit, `Enabled, enable);	
	UI::ChangeWidget (`menu, `Enabled, enable);
	
	return nil;
    }

// ************************************ Adapt firewall widget ********************

    /**
      * Initialization function for firewall adapting
      * @param key any option key to be initialized
      */
    global void initAdaptFirewall (string key) ``{
	if( SuSEFirewall::IsStarted() ) {
	    UI::ChangeWidget (`id (key), `Value, HttpServer::getFirewallStatus());
	    UI::ChangeWidget (`id (key), `Enabled, true );
	} else {
	    // disable the widget
	    UI::ChangeWidget (`id (key), `Enabled, false );
	}
    }

    /**
      * Store function for firewall adapting
      * @param opt_id any option id
      * @param event map event description
      */
    global void storeAdaptFirewall (string opt_id, map event) ``{
	if( SuSEFirewall::IsStarted() ) {
	    HttpServer::firewall = (boolean)UI::QueryWidget (`id (opt_id), `Value);
	    HttpServer::modified = true;
	}
    }
/* these are for future use: */

// error message - the entered ip address is not found
string __nonconfigured_ipaddress = _("The IP address is not configured
on this machine.");

// *********************** Wizard Dialog 1 Widgets *****************************************

  /**
   * Initialize open port
   * @param key string
   */
  global define void initOpenPort (string key) ``{
	string port=nil;

	foreach(map listens, YaST::HTTPDData::GetCurrentListen(), 
		{
		if ( port != "80" ) port = listens["PORT"]:"80";

		} );
 if ( port == nil ) port="80";
 y2milestone("Port finally :  %1", port);
 UI::ChangeWidget(`id(key), `Value, port);
 }

  /**
   * Handling open port
   * @param key string
   * @param event map
   * @return symbol nil
   */
global symbol handleOpenPort(string key, map event) ``{
 return nil;
}

  /**
   * Validation open port
   * @param key string
   * @param event string
   * @return boolean validate open port
   */
global boolean validateOpenPort(string key, map event) ``{
 string value = (string) UI::QueryWidget(`id(key), `Value);
 y2milestone("validate open port ... %1", value);
 if( ! regexpmatch( value, "^[ \t]*[0-9]+[ \t]*$" ) ) {
	//translators: popup error
	Popup::Error(_("Invalid port number."));
	 UI::SetFocus(`id(key));
	 return false;
	} else return true;
}

  /**
   * Initialize listen interfaces
   * @param key string
   */

global define void initListenInterfaces (string key) ``{

 y2milestone("Initializing Listen Interfaces ... %1", key);
 boolean all = false;
 foreach(map listens, YaST::HTTPDData::GetCurrentListen(),
  {
   if ( listens["ADDRESS"]:"" == "" ) all = true;

  } );

 list<term> ips =  maplist( string ip, string dev, HttpServer::ip2device, { 
	if (all) return `item(ip, true);
	 else {
	boolean checked = false;
	foreach(map listens, YaST::HTTPDData::GetCurrentListen(), {if ( listens["ADDRESS"]:"" == ip ) checked=true;});
	return `item(ip, checked);
	}
	} ) ;
//translators: multi selection box
 UI::ReplaceWidget(`id(mode_replace_point_key), `MultiSelectionBox(`id("multi_sel_box"),_("&Listen on Interfaces"),ips));
}

  /**
   * 
   * @param key string
   * @param event map
   * @return boolean validate interfaces
   */
global boolean validateListenInterfaces(string key, map event) ``{
 if( size((list)UI::QueryWidget( `id("multi_sel_box"), `SelectedItems )) < 1 ) {
	//translators: popup error - multi selection box with server network adresses
        Popup::Error(_("At least one interface must be selected."));
         UI::SetFocus(`id(key));
         return false;
        } else return true;
}


  /**
   * Initialize firewall settings
   * @param key string 
   */
global define void initFwOpen (string key) ``{
 y2milestone("initializing firewall open ...");
       if( SuSEFirewall::IsStarted() ) {
            UI::ChangeWidget (`id (key), `Value, true);
            UI::ChangeWidget (`id (key), `Enabled, true );
        } else {
            // disable the widget
            UI::ChangeWidget (`id (key), `Enabled, false );
        }
}

   /**
    * Store firewall settings
    * @param opt_id string 
    * @param event map
    */
    global define void storeFwOpen (string opt_id, map event) ``{
        if( SuSEFirewall::IsEnabled() || Mode::config ()) {
            HttpServer::firewall = (boolean)UI::QueryWidget (`id (opt_id), `Value);
            HttpServer::modified = true;
        }
    }


// *********************** Wizard Dialog 2 Widgets *****************************************
  /**
   * Initialization of checkboxes
   * @param key string
   */
define void initScriptModules(string key) ``{
	boolean enable_php5=false;
	boolean enable_perl=false;
	boolean enable_python=false;
	boolean enable_ruby=false;
list<string> modules = YaST::HTTPDData::GetModuleList();
	if (contains(modules, "php5")) enable_php5 = true;
	if (contains(modules, "perl")) enable_perl = true;
	if (contains(modules, "python")) enable_python = true;
	if (contains(modules, "ruby")) enable_ruby = true;

	UI::ReplaceWidget (`id (`scr_mod_replace),
		    `HBox(`HSpacing(6),
		     `VBox(
		     `VSpacing(3),	//translators: checkbox - support for php script language
                      `Left(`CheckBox(`id(`scr_mod_php5),_("Enable &PHP5 Scripting"), enable_php5)),
			`VSpacing(1),   //translators: checkbox - support for perl script language
                      `Left(`CheckBox(`id(`scr_mod_perl), _("Enable P&erl Scripting"), enable_perl)),
                        `VSpacing(1),   //translators: checkbox - support for python script language
                      `Left(`CheckBox(`id(`scr_mod_python), _("Enable P&ython Scripting"), enable_python)),
                        `VSpacing(1),   //translators: checkbox - support for ruby script language
                      `Left(`CheckBox(`id(`scr_mod_ruby), _("Enable &Ruby Scripting"), enable_ruby)),
		     `VSpacing(2) 
			)));
	y2milestone("initializing script modules");
}

// *********************** Wizard Dialog 5 Widgets *****************************************

  /**
   * Handler for expert configuration
   * @param key string
   * @param event map
   * @return symbol (nil, `expert)
   */
global define symbol handleExpertConf (string key, map event) ``{
 if (event["ID"]:nil == "expert_conf" )  
		{
		 init_tab="listen";
		 return (symbol) `expert;
		}
	else return (symbol) nil;
 }
  /**
   * Get service start
   * @return status boolean
   */

boolean getServiceAutoStart() ``{
 if (YaST::HTTPDData::GetService()!=nil && YaST::HTTPDData::GetService()) return true;
	else return false;
}

  /**
   * Set service start
   * @param status boolean
   */
void setServiceAutoStart(boolean status) ``{
 YaST::HTTPDData::ModifyService(status);
}

 /**
  * Initialize widget with summary text
  * @param key string
  */
define void initSummaryText (string key) ``{

   UI::ReplaceWidget(`id(`summary_text_rp), `RichText( HttpServer::Summary()[0]:"error" ));
}

/* EOF */
}

